default_platform(:ios)

platform :ios do
  desc "Build IPA for App Store via Flutter"
  lane :build do
    # Run CocoaPods/Flutter outside Bundler to avoid Ruby version conflicts
    require 'bundler'
    Bundler.with_unbundled_env do
      # Ensure Homebrew's pod takes precedence
      ENV['PATH'] = "/opt/homebrew/bin:/usr/local/bin:#{ENV['PATH']}"

      # Always run from repo root (Fastfile lives in fastlane/)
      repo_root = File.expand_path('..', __dir__)
      Dir.chdir(repo_root) do
        sh("which", "pod")
        sh("pod", "--version")
        sh("bash", "-lc", "cd ios && pod install")

        sh("flutter", "clean")
        sh("flutter", "pub", "get")
        sh("flutter", "build", "ipa", "--release")
      end
    end
  end

  desc "Upload build to TestFlight/App Store Connect"
  lane :upload do
    require 'json'
    repo_root = File.expand_path('..', __dir__)

    # Load App Store Connect API key (fastlane JSON format)
    api_key_json_path = File.join(repo_root, 'fastlane', 'api_key.json')
    UI.user_error!("Missing API key at #{api_key_json_path}") unless File.exist?(api_key_json_path)
    api_key_data = JSON.parse(File.read(api_key_json_path))
    api_key = app_store_connect_api_key(
      key_id: api_key_data['key_id'],
      issuer_id: api_key_data['issuer_id'],
      key_content: api_key_data['key'],
      is_key_content_base64: false,
      in_house: api_key_data['in_house'] || false
    )

    # Ensure metadata (categories, rights, copyright) is synced before upload
    deliver_metadata

    # Create the app in ASC if missing (ignore error if it already exists)
    begin
      produce(
        app_identifier: "dk.johndoktor.racedriver",
        app_name: "RaceDriver",
        sku: "racedriver-ios",
        platform: 'ios'
      )
    rescue => e
      UI.message("produce skipped or app already exists: #{e.message}")
    end

    # Pick the built IPA dynamically (Flutter may name it after the package)
    ipa_dir = File.join(repo_root, 'build/ios/ipa')
    ipa_path = Dir[File.join(ipa_dir, '*.ipa')].first
    UI.user_error!("Could not find any .ipa in #{ipa_dir}") unless ipa_path && File.exist?(ipa_path)

    pilot(
      api_key: api_key,
      ipa: ipa_path,
      app_identifier: "dk.johndoktor.racedriver",
      app_platform: "ios",
      skip_submission: true,
      skip_waiting_for_build_processing: false
    )
  end

  desc "Upload metadata only (no binary)"
  lane :deliver_metadata do
    # Defaults can be overridden via environment variables
    primary_category = ENV['APP_PRIMARY_CATEGORY'] || 'GAMES'
    primary_sub1 = ENV['APP_PRIMARY_SUB1'] || 'GAMES_RACING'
    primary_sub2 = ENV['APP_PRIMARY_SUB2'] || ''
    copyright_str = ENV['APP_COPYRIGHT'] || '© 2025 John Doktor. All rights reserved.'
    has_rights = (ENV['CONTENT_RIGHTS_HAS_RIGHTS'] || 'true').downcase == 'true'
    contains_third_party = (ENV['CONTENT_RIGHTS_CONTAINS_THIRD_PARTY'] || 'false').downcase == 'true'

    params = {
      api_key_path: "fastlane/api_key.json",
      skip_screenshots: true,
      skip_binary_upload: true,
      submit_for_review: false,
      force: true,
      run_precheck_before_submit: false,
      precheck_include_in_app_purchases: false,
      app_rating_config_path: File.join(File.expand_path('..', __dir__), 'fastlane', 'metadata', 'age_rating.json'),
      # App Information
      primary_category: primary_category,
      primary_first_sub_category: primary_sub1,
      # App Store Version
      copyright: copyright_str,
      # Compliance/Content Rights (review submission info)
      submission_information: {
        content_rights_has_rights: has_rights,
        content_rights_contains_third_party_content: contains_third_party
      }
    }
    params[:primary_second_sub_category] = primary_sub2 unless primary_sub2.nil? || primary_sub2.strip.empty?
    deliver(**params)
  end

  desc "Set App Privacy to 'No data collected'"
  lane :set_app_privacy_no_data do
    require 'json'
    # Uses Appfile bundle id
    upload_app_privacy_details_to_app_store(
      api_key_path: "fastlane/api_key.json",
      app_identifier: CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier) || ENV['APP_IDENTIFIER'] || "dk.johndoktor.racedriver",
      privacy_types: [],
      includes_tracking: false,
      uses_idfa: false,
      output_skip_publish: false
    )
  end

  desc "Set App Information: category, content rights, copyright"
  lane :set_app_information do
    require 'json'

    primary_category = ENV['APP_PRIMARY_CATEGORY'] || 'Games'
    primary_sub1 = ENV['APP_PRIMARY_SUB1'] || 'Racing'
    primary_sub2 = ENV['APP_PRIMARY_SUB2'] || 'Arcade'
    copyright_str = ENV['APP_COPYRIGHT'] || '© 2025 John Doktor. All rights reserved.'
    has_rights = (ENV['CONTENT_RIGHTS_HAS_RIGHTS'] || 'true').downcase == 'true'
    contains_third_party = (ENV['CONTENT_RIGHTS_CONTAINS_THIRD_PARTY'] || 'false').downcase == 'true'

    api_key_json_path = File.join(__dir__, 'api_key.json')
    UI.user_error!("Missing API key at #{api_key_json_path}") unless File.exist?(api_key_json_path)
    api_key_data = JSON.parse(File.read(api_key_json_path))
    app_store_connect_api_key(
      key_id: api_key_data['key_id'],
      issuer_id: api_key_data['issuer_id'],
      key_content: api_key_data['key'],
      is_key_content_base64: false,
      in_house: api_key_data['in_house'] || false
    )

    require 'spaceship'
    require 'credentials_manager'
    bundle_id = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier) || ENV['APP_IDENTIFIER'] || "dk.johndoktor.racedriver"
    app = Spaceship::ConnectAPI::App.find(bundle_id)
    UI.user_error!("App not found in App Store Connect: #{bundle_id}") unless app

    app_info = app.fetch_edit_app_info || app.fetch_latest_app_info
    UI.user_error!("App info not found") unless app_info

    UI.message("Updating App Information: category + copyright...")
    begin
      app_info.update(attributes: {
        primaryCategory: primary_category,
        primarySubcategoryOne: primary_sub1,
        primarySubcategoryTwo: primary_sub2,
        copyright: copyright_str
      })
    rescue => e
      UI.important("Category/copyright update failed: #{e.message}")
    end

    UI.message("Updating Content Rights declaration...")
    begin
      # Try to fetch and update the content rights declaration via Connect API
      # Depending on fastlane version, this may be exposed as below; otherwise fallback to UI manual.
      if app_info.respond_to?(:get_content_rights_declaration)
        cr = app_info.get_content_rights_declaration
        if cr.nil?
          if app_info.respond_to?(:create_content_rights_declaration)
            app_info.create_content_rights_declaration(attributes: {
              hasRights: has_rights,
              containsThirdPartyContent: contains_third_party
            })
          end
        else
          cr.update(attributes: {
            hasRights: has_rights,
            containsThirdPartyContent: contains_third_party
          })
        end
      else
        # As a fallback, attempt generic update if supported by current spaceship
        app_info.update(attributes: {
          contentRightsDeclaration: {
            hasRights: has_rights,
            containsThirdPartyContent: contains_third_party
          }
        })
      end
    rescue => e
      UI.important("Content Rights update not supported by current fastlane/spaceship or failed: #{e.message}. You may need to set it once in App Store Connect UI.")
    end
  end

  desc "Set promotional text only (no other metadata)"
  lane :set_promotional_text do
    require 'json'
    repo_root = File.expand_path('..', __dir__)

    text_path = File.join(repo_root, 'fastlane', 'metadata', 'en-US', 'promotional_text.txt')
    UI.user_error!("Missing promotional text at #{text_path}") unless File.exist?(text_path)
    promo_text = File.read(text_path).strip
    UI.user_error!("Promotional text must be <= 170 characters") if promo_text.length > 170

    api_key_json_path = File.join(repo_root, 'fastlane', 'api_key.json')
    UI.user_error!("Missing API key at #{api_key_json_path}") unless File.exist?(api_key_json_path)
    api_key_data = JSON.parse(File.read(api_key_json_path))
    app_store_connect_api_key(
      key_id: api_key_data['key_id'],
      issuer_id: api_key_data['issuer_id'],
      key_content: api_key_data['key'],
      is_key_content_base64: false,
      in_house: api_key_data['in_house'] || false
    )

    require 'spaceship'
    app = Spaceship::ConnectAPI::App.find("dk.johndoktor.racedriver")
    UI.user_error!("App not found in App Store Connect") unless app

    version = app.get_edit_app_store_version
    version ||= app.get_latest_app_store_version
    UI.user_error!("No App Store version found to edit") unless version

    localizations = version.get_app_store_version_localizations
    loc = localizations.find { |l| l.locale == 'en-US' }

    if loc.nil?
      UI.message("Creating en-US version localization with promotional text...")
      version.create_app_store_version_localization(attributes: { locale: 'en-US', promotionalText: promo_text })
    else
      UI.message("Updating promotional text for en-US...")
      loc.update(attributes: { promotionalText: promo_text })
    end
  end

  desc "Set app info localization (name, subtitle)"
  lane :set_app_info do
    require 'json'
    repo_root = File.expand_path('..', __dir__)

    name_path = File.join(repo_root, 'fastlane', 'metadata', 'en-US', 'name.txt')
    subtitle_path = File.join(repo_root, 'fastlane', 'metadata', 'en-US', 'subtitle.txt')
    UI.user_error!("Missing name at #{name_path}") unless File.exist?(name_path)
    UI.user_error!("Missing subtitle at #{subtitle_path}") unless File.exist?(subtitle_path)
    name = File.read(name_path).strip
    subtitle = File.read(subtitle_path).strip
    UI.user_error!("Subtitle must be <= 30 chars") if subtitle.length > 30

    api_key_json_path = File.join(repo_root, 'fastlane', 'api_key.json')
    UI.user_error!("Missing API key at #{api_key_json_path}") unless File.exist?(api_key_json_path)
    api_key_data = JSON.parse(File.read(api_key_json_path))
    app_store_connect_api_key(
      key_id: api_key_data['key_id'],
      issuer_id: api_key_data['issuer_id'],
      key_content: api_key_data['key'],
      is_key_content_base64: false,
      in_house: api_key_data['in_house'] || false
    )

    require 'spaceship'
    app = Spaceship::ConnectAPI::App.find("dk.johndoktor.racedriver")
    UI.user_error!("App not found in App Store Connect") unless app

    app_info = app.fetch_latest_app_info || app.fetch_edit_app_info
    UI.user_error!("App info not found") unless app_info
    localizations = app_info.get_app_info_localizations
    loc = localizations.find { |l| l.locale == 'en-US' }

    if loc.nil?
      UI.message("Creating en-US app info localization with name/subtitle...")
      app_info.create_app_info_localization(attributes: { locale: 'en-US', name: name, subtitle: subtitle })
    else
      UI.message("Updating name/subtitle for en-US app info...")
      loc.update(attributes: { name: name, subtitle: subtitle })
    end
  end

  desc "Build and upload"
  lane :release do
    build
    upload
  end

  desc "Build and distribute to TestFlight group, notify testers"
  lane :beta do
    build

    require 'json'
    repo_root = File.expand_path('..', __dir__)
    api_key_json_path = File.join(repo_root, 'fastlane', 'api_key.json')
    UI.user_error!("Missing API key at #{api_key_json_path}") unless File.exist?(api_key_json_path)
    api_key_data = JSON.parse(File.read(api_key_json_path))
    app_store_connect_api_key(
      key_id: api_key_data['key_id'],
      issuer_id: api_key_data['issuer_id'],
      key_content: api_key_data['key'],
      is_key_content_base64: false,
      in_house: api_key_data['in_house'] || false
    )

    group_name = "External Testers"
    require 'spaceship'
    app = Spaceship::ConnectAPI::App.find("dk.johndoktor.racedriver")
    UI.user_error!("App not found in App Store Connect") unless app
    groups = app.get_beta_groups
    group = groups.find { |g| g.name == group_name }
    if group.nil?
      UI.message("Creating TestFlight group '#{group_name}'...")
      group = app.create_beta_group(group_name: group_name, is_internal_group: false, has_access_to_all_builds: true)
    end

    # Upload and distribute to external testers
    repo_root = File.expand_path('..', __dir__)
    ipa_dir = File.join(repo_root, 'build/ios/ipa')
    ipa_path = Dir[File.join(ipa_dir, '*.ipa')].first
    UI.user_error!("Could not find any .ipa in #{ipa_dir}") unless ipa_path && File.exist?(ipa_path)

    # Beta review metadata
    beta_desc_path = File.join(repo_root, 'fastlane', 'metadata', 'en-US', 'beta_app_description.txt')
    beta_description = if File.exist?(beta_desc_path)
      File.read(beta_desc_path).strip
    else
      # fallback to promotional text or description
      promo = File.join(repo_root, 'fastlane', 'metadata', 'en-US', 'promotional_text.txt')
      descf = File.join(repo_root, 'fastlane', 'metadata', 'en-US', 'description.txt')
      if File.exist?(promo)
        File.read(promo).strip
      elsif File.exist?(descf)
        File.read(descf)[0, 400].strip
      else
        'Beta build of MicroRaceDriver with performance improvements.'
      end
    end
    beta_feedback_email = ENV['BETA_FEEDBACK_EMAIL'] || UI.user_error!("Set BETA_FEEDBACK_EMAIL with a valid contact email for TestFlight beta.")

    pilot(
      api_key_path: "fastlane/api_key.json",
      ipa: ipa_path,
      app_identifier: "dk.johndoktor.racedriver",
      app_platform: "ios",
      distribute_external: true,
      groups: [group_name],
      notify_external_testers: true,
      changelog: File.exist?(File.join(repo_root, 'fastlane', 'metadata', 'en-US', 'release_notes.txt')) ? File.read(File.join(repo_root, 'fastlane', 'metadata', 'en-US', 'release_notes.txt')).strip : "Performance optimizations, improved stability, and new app icon/splash.",
      beta_app_description: beta_description,
      beta_app_feedback_email: beta_feedback_email,
      demo_account_required: false,
      beta_app_review_info: { contact_email: beta_feedback_email },
      skip_waiting_for_build_processing: false
    )
  end
end

platform :android do
  desc "Build Android App Bundle (prod)"
  lane :build do
    sh("flutter", "clean")
    sh("flutter", "pub", "get")
    sh("flutter", "build", "appbundle", "--release", "--flavor", "prod")
  end

  desc "Upload Android AAB to Internal testing on Google Play"
  lane :upload_internal do |options|
    # Locate service account JSON via env or file
    json_key_path = options[:json_key_path] || ENV['PLAY_JSON_PATH'] || File.exist?("fastlane/play.json") && "fastlane/play.json"
    json_key_data = ENV['PLAY_JSON']
    aab_path = options[:aab] || "build/app/outputs/bundle/prodRelease/app-prod-release.aab"

    UI.user_error!("AAB not found at #{aab_path}") unless File.exist?(aab_path)
    if json_key_data.nil? && (json_key_path.nil? || !File.exist?(json_key_path))
      UI.user_error!("Provide Google Play service account JSON via PLAY_JSON env or play.json at fastlane/play.json")
    end

    supply(
      package_name: "dk.johndoktor.racedriver",
      aab: aab_path,
      track: "internal",
      json_key: json_key_path,
      json_key_data: json_key_data,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      skip_upload_metadata: true
    )
  end

  desc "Build and upload to Internal testing"
  lane :internal do
    build
    upload_internal
  end
end
